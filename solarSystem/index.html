<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>真实比例太阳系 (专业控制版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', monospace; color: white; }

        /* 通用 HUD 样式 */
        .hud-panel {
            position: absolute;
            background: rgba(10, 15, 20, 0.7);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            backdrop-filter: blur(5px);
            padding: 10px;
            pointer-events: auto; /* 允许点击 */
        }

        /* 左上角：距离显示 */
        #hud-distance {
            top: 20px;
            left: 20px;
            min-width: 200px;
        }
        .data-label { color: #88aaff; font-size: 12px; }
        .data-value { font-size: 16px; font-weight: bold; color: #fff; }

        /* 左下角：时间流速输入 */
        #hud-speed {
            bottom: 80px; /* 抬高一点，给底部距离条留位置 */
            left: 20px;
            width: 220px;
        }
        #speed-input {
            width: 100%;
            background: rgba(0,0,0,0.5);
            border: 1px solid #445566;
            color: #00d2ff;
            padding: 5px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            margin-top: 5px;
        }

        /* 底部：距离控制条 */
        #bottom-control {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%; /* 占据屏幕宽度的60% */
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 900;
        }
        #dist-slider {
            flex-grow: 1;
            cursor: pointer;
            accent-color: #0096ff;
        }
        .slider-label { font-size: 12px; color: #aaa; white-space: nowrap; }

        /* 右上角：固定按钮 */
        #toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 150, 255, 0.2);
            border: 1px solid rgba(0, 150, 255, 0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #toggle-btn:hover { background: rgba(0, 150, 255, 0.8); }

        /* 右侧侧边栏 */
        #sidebar {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 220px;
            max-height: 80vh;
            background: rgba(10, 12, 18, 0.95);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            transform: translateX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #sidebar.hidden { transform: translateX(130%); pointer-events: none; }

        #content { overflow-y: auto; flex: 1; }
        ul { list-style: none; padding: 0; margin: 0; }
        li {
            padding: 12px 20px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 14px; color: #ccc; transition: 0.2s;
        }
        li:hover { background: rgba(255,255,255,0.1); color: #fff; }
        li.active { background: rgba(0, 150, 255, 0.2); border-left: 3px solid #0096ff; color: #fff; }

        /* 滚动条 */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script>
        function beginTapTips() {
            alert("建议用电脑打开哟，全屏横屏效果更佳");
        }
        function usingintroducation() {
            alert("模型大小和轨道半径都是真实比例\n按住左键拖动屏幕旋转视角，滚动鼠标中建滚轮缩放视角\n——和谷歌的Gemini 3 Pro一起做的，AI真难调 :( ——")
        }
        window.onload = beginTapTips();
        window.onload = usingintroducation();
    </script>
</head>
<body>

<!-- 左上角距离 -->
<div id="hud-distance" class="hud-panel">
    <div class="data-label">当前聚焦</div>
    <div class="data-value" id="dist-target">--</div>
    <div style="margin-top:8px;" class="data-label">摄像机距表面</div>
    <div class="data-value"><span id="dist-val">0</span> km</div>
</div>

<!-- 左下角时间控制 -->
<div id="hud-speed" class="hud-panel">
    <div class="data-label">时间倍速 (1.0 = 实时)</div>
    <input type="number" id="speed-input" value="1" min="0" step="100">
    <div style="font-size:11px; color:#666; margin-top:4px;">建议: 100,000+ 可见公转</div>
</div>

<!-- 底部距离控制条 -->
<div id="bottom-control" class="hud-panel">
    <span class="slider-label">贴近观察</span>
    <input type="range" id="dist-slider" min="0" max="100" step="0.1" value="0">
    <span class="slider-label">太阳系全景</span>
</div>

<!-- 右上角按钮 -->
<button id="toggle-btn">☰ 星体列表</button>

<!-- 侧边栏 -->
<div id="sidebar">
    <div style="padding:15px; border-bottom:1px solid rgba(255,255,255,0.1); color:#88aaff; font-weight:bold;">SOLAR SYSTEM</div>
    <div id="content">
        <ul id="planet-list"></ul>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 核心配置 ---
    // 1 Scene Unit = 1000 km
    const KM_TO_UNIT = 0.001;
    const UNIT_TO_KM = 1000;

    // 真实公转周期 (地球日)
    const PERIODS = {
        "水星": 87.97, "金星": 224.7, "地球": 365.25, "火星": 686.97,
        "木星": 4332.59, "土星": 10759.22, "天王星": 30685.4, "海王星": 60189.0
    };

    const CELESTIAL_DATA = [
        { name: "太阳", type: "star", radius: 696000, distance: 0, color: 0xFFD700 },
        { name: "水星", type: "planet", radius: 2440, distance: 57000000, color: 0xB0B0B0 },
        { name: "金星", type: "planet", radius: 6052, distance: 108000000, color: 0xE6C288 },
        { name: "地球", type: "planet", radius: 6378, distance: 150000000, color: 0x4da6ff },
        { name: "火星", type: "planet", radius: 3397, distance: 228000000, color: 0xFF5733 },
        { name: "木星", type: "planet", radius: 71492, distance: 780000000, color: 0xE0AE6F },
        { name: "土星", type: "planet", radius: 60268, distance: 1437000000, color: 0xF0E68C, hasRing: true },
        { name: "天王星", type: "planet", radius: 25559, distance: 2883000000, color: 0x7FFFD4 },
        { name: "海王星", type: "planet", radius: 24764, distance: 4507500000, color: 0x5070FF }
    ];

    // 全局变量
    let scene, camera, renderer, controls;
    let celestialMap = {};
    let currentTarget = null;
    let timeMultiplier = 1.0;
    const clock = new THREE.Clock();

    // 距离控制相关
    const SYSTEM_RADIUS_UNIT = 5000000; // 50亿公里 (覆盖海王星)
    // 计算最大回退距离：让太阳系半径占屏幕约50%
    // distance = radius / tan(FOV/2). tan(30deg) ≈ 0.577
    const MAX_ZOOM_OUT = SYSTEM_RADIUS_UNIT / 0.5;

    init();
    animate();

    function init() {
        scene = new THREE.Scene();

        // 摄像机 (Far Plane 必须很大)
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, MAX_ZOOM_OUT * 2);

        renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 光照
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const sunLight = new THREE.PointLight(0xffffff, 2.0, 0);
        scene.add(sunLight);

        createDarkBackground(); // 暗背景
        createSolarSystem();
        initUI();

        setFocus("太阳");

        window.addEventListener('resize', onWindowResize);
    }

    function createSolarSystem() {
        CELESTIAL_DATA.forEach(data => {
            const r_unit = data.radius * KM_TO_UNIT;
            const d_unit = data.distance * KM_TO_UNIT;

            let material;
            if (data.type === 'star') {
                material = new THREE.MeshBasicMaterial({ color: data.color });
                // 简单的光晕
                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(r_unit * 1.2, 32, 32),
                    new THREE.MeshBasicMaterial({ color: data.color, transparent: true, opacity: 0.2 })
                );
                scene.add(glow);
            } else {
                material = new THREE.MeshStandardMaterial({
                    color: data.color, roughness: 0.7, metalness: 0.1
                });
            }

            const geometry = new THREE.SphereGeometry(r_unit, 64, 64);
            const mesh = new THREE.Mesh(geometry, material);

            const group = new THREE.Group();
            group.add(mesh);
            scene.add(group);

            if (data.hasRing) {
                const ringGeo = new THREE.RingGeometry(r_unit * 1.4, r_unit * 2.2, 64);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0xCDCDB4, side: THREE.DoubleSide, transparent: true, opacity: 0.6
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                mesh.add(ring);
            }

            if (data.distance > 0) {
                const points = [];
                const segs = 256;
                for (let i = 0; i <= segs; i++) {
                    const theta = (i / segs) * Math.PI * 2;
                    points.push(new THREE.Vector3(Math.cos(theta) * d_unit, 0, Math.sin(theta) * d_unit));
                }
                const orbitGeo = new THREE.BufferGeometry().setFromPoints(points);
                const orbitMat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.4 });
                scene.add(new THREE.Line(orbitGeo, orbitMat));
            }

            let angularVelocity = 0;
            if (PERIODS[data.name]) {
                const secondsPerPeriod = PERIODS[data.name] * 24 * 3600;
                angularVelocity = (2 * Math.PI) / secondsPerPeriod;
            }

            celestialMap[data.name] = {
                mesh: mesh, group: group, data: data,
                angle: Math.random() * Math.PI * 2,
                distanceUnit: d_unit, radiusUnit: r_unit,
                angularVelocity: angularVelocity
            };
        });
    }

    // 修改：背景变暗
    function createDarkBackground() {
        const geometry = new THREE.BufferGeometry();
        const count = 5000;
        const positions = [];
        const dist = MAX_ZOOM_OUT * 1.5;

        for (let i = 0; i < count; i++) {
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            const x = dist * Math.sin(phi) * Math.cos(theta);
            const y = dist * Math.sin(phi) * Math.sin(theta);
            const z = dist * Math.cos(phi);
            positions.push(x, y, z);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        // 颜色改为深灰 (0x444444)，不透明度降低
        const material = new THREE.PointsMaterial({
            color: 0x444444,
            size: 3,
            sizeAttenuation: false,
            transparent: true,
            opacity: 0.5
        });
        const stars = new THREE.Points(geometry, material);
        scene.add(stars);
    }

    function initUI() {
        const list = document.getElementById('planet-list');
        const speedInput = document.getElementById('speed-input');
        const toggleBtn = document.getElementById('toggle-btn');
        const sidebar = document.getElementById('sidebar');
        const slider = document.getElementById('dist-slider');

        // 1. 列表逻辑
        Object.keys(celestialMap).forEach(key => {
            const li = document.createElement('li');
            li.textContent = key;
            li.onclick = () => {
                document.querySelectorAll('li').forEach(el => el.classList.remove('active'));
                li.classList.add('active');
                setFocus(key);
            };
            list.appendChild(li);
        });
        list.children[0].classList.add('active');

        // 2. 时间输入逻辑
        speedInput.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            if(isNaN(val) || val < 0) val = 0;
            timeMultiplier = val;
        });

        // 3. 距离滑块逻辑 (拖动滑块 -> 改变相机位置)
        slider.addEventListener('input', () => {
            if(!currentTarget) return;

            // 对数映射: 将 0-100 映射到 minDist - maxDist
            const minD = currentTarget.radiusUnit * 2.0; // 最小距离
            const maxD = MAX_ZOOM_OUT; // 最大距离 (太阳系全景)

            // 对数公式: value = log(dist)
            const pct = slider.value / 100;
            const dist = minD * Math.pow((maxD / minD), pct);

            // 设置 OrbitControls 距离 (它会自动调整相机位置)
            // 注意：我们需要更新 min/max 以允许这个距离，然后再限制回来
            controls.minDistance = 0;
            controls.maxDistance = MAX_ZOOM_OUT * 2;

            // 获取当前方向向量
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            // 应用新距离
            camera.position.copy(controls.target).add(direction.multiplyScalar(dist));

            // 恢复限制将在 setFocus 或下一帧逻辑中处理，这里为了拖动流畅暂时放宽
        });

        // 4. 侧边栏
        let isExpanded = true;
        toggleBtn.onclick = () => {
            isExpanded = !isExpanded;
            if (isExpanded) {
                sidebar.classList.remove('hidden');
                toggleBtn.textContent = '✕ 收起';
            } else {
                sidebar.classList.add('hidden');
                toggleBtn.textContent = '☰ 星体列表';
            }
        };
        toggleBtn.textContent = '✕ 收起';
    }

    function setFocus(name) {
        if (celestialMap[name]) {
            const obj = celestialMap[name];
            currentTarget = obj;
            document.getElementById('dist-target').textContent = name;

            // 设置缩放限制
            // 最小：星球半径 * 1.1 (贴脸)
            // 最大：全景距离 (无论看谁，都可以拉远到看整个太阳系)
            controls.minDistance = obj.radiusUnit * 1.1;
            controls.maxDistance = MAX_ZOOM_OUT;

            // 如果当前距离太近（比如从太阳切到水星），相机可能会在水星内部
            // 这里做一个简单的自动弹开逻辑
            const currentDist = camera.position.distanceTo(controls.target);
            if (currentDist < controls.minDistance) {
                const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(controls.target).add(dir.multiplyScalar(controls.minDistance * 2));
            }
        }
    }

    function updateHUDAndSlider() {
        if (!currentTarget) return;

        // 1. 更新距离文字
        const distUnit = camera.position.distanceTo(currentTarget.group.position);
        const surfaceDistUnit = Math.max(0, distUnit - currentTarget.radiusUnit);
        const km = Math.round(surfaceDistUnit * UNIT_TO_KM);
        document.getElementById('dist-val').textContent = km.toLocaleString();

        // 2. 反向更新滑块 (根据当前相机距离更新滑块位置)
        // 只有当用户没有正在拖动滑块时才更新 (防止抖动，但在Web中input=range没有isDragging状态，
        // 通常如果input事件频繁触发这里可能会冲突，但OrbitControls的阻尼和input通常能共存)

        const minD = currentTarget.radiusUnit * 2.0;
        const maxD = MAX_ZOOM_OUT;

        // 限制范围防止计算错误
        const clampedDist = Math.max(minD, Math.min(distUnit, maxD));

        // 对数逆运算: pct = log(dist / min) / log(max / min)
        let pct = Math.log(clampedDist / minD) / Math.log(maxD / minD);
        if(pct < 0) pct = 0;
        if(pct > 1) pct = 1;

        // 只有当滑块没有被鼠标聚焦时才自动更新（简易防冲突）
        if(document.activeElement !== document.getElementById('dist-slider')) {
            document.getElementById('dist-slider').value = pct * 100;
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        // 行星公转
        Object.values(celestialMap).forEach(obj => {
            if (obj.angularVelocity > 0) {
                obj.angle += obj.angularVelocity * delta * timeMultiplier;
                obj.group.position.x = Math.cos(obj.angle) * obj.distanceUnit;
                obj.group.position.z = Math.sin(obj.angle) * obj.distanceUnit;
            }
            obj.mesh.rotation.y += 0.5 * delta;
        });

        // 摄像机跟随
        if (currentTarget) {
            const targetPos = currentTarget.group.position;
            controls.target.set(targetPos.x, targetPos.y, targetPos.z);
        }

        updateHUDAndSlider();
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>